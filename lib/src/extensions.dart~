
    void add(String key,dynamic val){
      if(this.has(key)) return null;
      this.storage[key] = val;
    }

    void update(String key,dynamic val){
      if(this.has(key)){ this.storage[key] = val; return null; }
      else this.add(key,val);
      return null;
    }

    void updateKey(String key,String newKey){
      if(!this.has(key)) return null;
      var val = this.get(key);
      this.destroy(key);
      this.add(newKey,val);
    }

    dynamic destroy(String key){
      if(!this.has(key)) return null; 
      return this.storage.remove(key);    
    }
      
    bool has(String key){
      if(!this.storage.containsKey(key)) return false;
      return true;
    }

    bool hasValue(String v){
      if(!this.storage.containsValue(v)) return false;
      return true;
    }

    void onAll(Function n) => this.storage.forEach(n);

    void flush(){
      this.storage.clear();
    }

    void clear() => this.flush();

    String toString(){
      return this.storage.toString();
    }

    int get keyLength => this.storage.keys.toList().length;
    int get valuesLength => this.storage.values.toList().length;
    int get length => this.storage.length;

    bool get isEmpty => this.storage.isEmpty;

    Map get core => this.storage;

}


class Counter{
  int _count = 0;
  dynamic handler;
  
  static create(n) => new Counter(n);

  Counter(this.handler);
  
  int get counter => _count;
  
  void tick(){
    _count += 1;
  }
  
  void untick(){
    if(_count == 0) return null;
    _count -= 1;
  }
  
  void detonate(){
    _count = 0;
  }
  
  String toString(){
    return "Counter: "+this.counter.toString();
  }
}

class MassTree extends MapDecorator{
  final canDestroy = Switch.create();

  static create() => new MassTree();

  MassTree();

  dynamic destroy(String key){
    if(!this.canDestroy.on()) return null;
    return super.destroy(key);
  }

  void addAll(Map n){
    n.forEach((n,k){
      this.add(n,k);
    });
  }
}

//StateObject with map get and setters
class State{
  final MapDecorator states = new MapDecorator();
  dynamic target;
  String name;
  bool _active = false;
 
  static create(t,s,[n]) => new State(t,s,n);
  
  State(this.target,Map sets,[String name]){
    this.name = Hub.switchUnless(name, 'StateObject');
    //if init and dinit do not exist,provide empty shell,just in case we wish to do some work
    if(this.states.get('init') == null) this.states.add('init', _empty);
    if(this.states.get('dinit') == null) this.states.add('dinit',_empty);
    
    sets.forEach((n,k){
      this.add(n,(){
        if(this.deactivated) return null;
        var m = k(this.target,this);
        return m;
      }); 
    });
  }
  
  void add(String key,Function n){
    this.states.add(key,n);
  }

  void activate(){
    this.states.get('init')(this.target,this);
    this._active = true;
  }
  
  void deactivate(){
    this.states.get('dinit')(this.target,this);
    this._active = false;
  }
  
  Function get(String n){
    return this.states.get(n);
  }
  
  dynamic run(String n){
    if(!this.states.has(n)) return null;
    return this.get(n)();
  }
  
  Function destroy(String n){
    return this.states.destroy(n);
  }

  vid close(){
     this.states.flush();
  }
  
  bool get activated => !!this._active;
  bool get deactivated => !this._active;
  
}

//using function calls and not dynamic invocation
class StateManager{
    Object target;
    dynamic store,current;
    
    static create(t) => new StateManager(t);
    
    StateManager(this.target){
      this.store = Hub.createMapDecorator();
    }
    
    void close(){
     this.store.onAll((e,k){ k.close(); });
     this.store.flush();
    }
    
    void add(String name,dynamic m){
      if(m is State) return this._addState(name, m);
      return this._createState(name, m);
    }
    
    void _createState(String name,Map<String,Function> states){
      this.store.add(name,new State(this.target,states,name));
    }
    
    void _addState(String name,State state){
      this.store.add(name,state);  
    }
    
    void removeState(String name){
      this.store.destroy(name);
    }

    dynamic run(String name){
      if(!this.isReady) return null;
      return this.current.run(name);
    }
    
    void switchState(String name){
      if(!this.store.has(name)) return;
      if(this.current != null) this.current.deactivate();
      this.current = this.store.get(name);
      this.current.activate();
      return;
    }
    
    bool get isReady => this.current != null;
    
}

class DurationMixin {
  dynamic incMillisFn(Duration n,int m) => new Duration(milliseconds: n.inMilliseconds + m);
  dynamic incMacrosFn(Duration n,int m) => new Duration(microseconds: n.inMicroseconds + m);
  dynamic decMillisFn(Duration n,int m) => new Duration(milliseconds: n.inMilliseconds - m);
  dynamic decMacrosFn(Duration n,int m) => new Duration(microseconds: n.inMicroseconds - m);
}

abstract class Queueable<T>{
  void queue(T n);
  void dequeueAt(int i);
  void dequeueFirst();
  void dequeueLast();
  void exec();
  void halt();
  void immediate();
}

class TaskQueue extends Queueable with DurationMixin{
  bool _auto,_halt = false,_lock = false,_forceSingleRun = false;
  Timer _timer;
  List tasks;
  List microtasks;
  Duration _queueDelay;

  static create([n]) => new TaskQueue(n);

  TaskQueue([auto]){
    this._auto = Funcs.switchUnless(auto,true);
    this.tasks = new List<Function>();
    this.microtasks = new List<Function>();
    this._queueDelay = Duration.ZERO;
  }

  void queue(Function n(m)){
    if(this.locked) return null;
    this.tasks.add(n);
    return ((!this.singleRun && this.waiting && this.auto) ? this.exec() : null);
  }
  void queueAfter(int ms,Function n(m)){
    new Timer(new Duration(milliseconds:ms),(){ this.queue(n); });
  }
  
  Timer queueEvery(int ms,Function n(m)){
    return new Timer.periodic(new Duration(milliseconds:ms),(t){ this.queue(n); });
  }

  dynamic dequeueAt(int i) => !this.locked && this.tasks.removeAt(i);
  dynamic dequeueFirst() => this.dequeueAt(0);
  dynamic dequeueLast() => this.dequeueAt(this.tasks.length - 1);

  void delay(int ms) => this._queueDelay = new Duration(milliseconds: ms);
  void incDelay(int ms) => this.incMillisFn(this._queueDelay,ms);
  void decDelay(int ms) => this.decMillisFn(this._queueDelay,ms);
  void forceSingleRun() => this._forceSingleRun = true;
  void disableSingleRun() => this._forceSingleRun = false;

  bool get locked => !!this._lock;
  bool get empty => this.tasks.isEmpty && this.microtasks.isEmpty;
  bool get waiting => !this.empty;
  bool get auto => !!this._auto;
  bool get halted => !!this._halt;
  bool get singleRun => !!this._forceSingleRun;

  int get totalJobs => this.tasks.length + this.microtasks.length;
  int get totalTasks => this.tasks.length;
  int get totalMicrotasks => this.microtasks.length;

  void _handleTasks(List cur,int n,[dynamic val]){
    if(cur.length <= n) return null;
    return cur.removeAt(n)(val);
  }

  void immediate(Function n(m)){
    if(this.locked) return null;
    this.microtasks.add(n);
  }

  void immediateFor(int i){
    if(this.locked) return null;
    if(this.tasks.isEmpty || this.tasks.length <= i) return null;
    var cur = this.tasks.removeAt(i);
    this.microtasks.add(cur);
  }

  void downgrade(int n){
    if(this.locked) return null;
    if(this.microtasks.isEmpty || this.microtasks.length <= n) return null;
    this.tasks.add(this.microtasks.removeAt(n));
  }

  void repeat(int n){
    if(this.locked) return null;
    if(this.tasks.isEmpty || this.tasks.length <= n) return null;
    this.tasks.add(this.tasks.elementAt(n));
  }

  void repeatImmediate(int n){
    if(this.locked) return null;
    if(this.microtasks.isEmpty || this.microtasks.length <= n) return null;
    this.microtasks.add(this.microtasks.elementAt(n));
  }

  int taskIndex(Function n) => this.tasks.indexOf(n);
  int microtaskIndex(Function n) => this.microtasks.indexOf(n);

  void exec([dynamic v]){
    if(this.empty || this.locked || this.halted) return null;
    this._timer = new Timer(this._queueDelay,(){
      this._handler(v);
      if(!this.singleRun) this.exec(v);
    });
  }

  void _handler([v]){
      if((this.tasks.length <= 0 && this.microtasks.length <= 0)) return null;
      if(this.microtasks.length > 0) this._handleTasks(this.microtasks,0,v);
      else this._handleTasks(this.tasks,0,v);
      this.end();
  }

  void halt(){
    this._halt = true;
  }

  void unhalt(){
    this._halt = false;
  }

  void end(){
    this._timer.cancel();
    this._timer = null;
  }

  void clearMicrotasks(){
    this.halt();
    this.microtasks.clear();
    this.unhalt();
  }

  void clearTasks(){
    this.halt();
    this.tasks.clear();
    this.unhalt();
  }

  void clearJobs(){
    this.clearMicrotasks();
    this.clearTasks();
  }

  void destroy(){
    this.end();
    this._queueDelay = null;
  }

  void forceUnlock(){
    this._lock = false;
  }

  void reset(){
    this._halt = false;
    this.disableSingleRun();
    this.forceUnlock();
  }
}


class Pipe{
  String id;
  dynamic pin,pout;
  dynamic out = Hub.createDistributor('pipe-out');

  static create(String id) => new Pipe(id);

  Pipe(this.id){
    this.pout = Hub.createDistributor('pipe-out');
    this.pin = Hub.createDistributor('pipe-in');
  }

  bool get active => Valids.exist(this.pout) && Valids.exist(this.pin);

  void sendOut(dynamic n){
    if(!this.active) return null;
    this.pout.emit(n);
  }

  void sendIn(dynamic n){
    if(!this.active) return null;
    this.pin.emit(n);
  }

  void recieve(Function m){
    if(!this.active) return null;
    this.pin.on(m);
  }

  void recieveOnce(Function m){
    if(!this.active) return null;
    this.pin.once(m);
  }

  void unrecieve(Function m){
    if(!this.active) return null;
    this.pin.off(m);
  }

  void unrecieveOnce(Function m){
    if(!this.active) return null;
    this.pin.offOnce(m);
  }

  void destroy(){
    if(!this.active) return null;
    this.pin.free();
    this.pout.free();
    this.pin = this.pout = null;
  }
}


class FunctionFactory{
	MapDecorator _hidden,factories;

	static create() => new FunctionFactory();

	FunctionFactory(){
		this._hidden = MapDecorator.create();
		this.factories = MapDecorator.create();
	}

	void addFactory(String name,Function n(e)){
		this._hidden.add(name,n);
		this.factories.add(name,(n){
			return this._hidden.get(name)(n);
		});
	}

	Function updateFactory(String name,Function n(e)){
		this._hidden.update(name,n);
	}

	void removeFactory(String name){
		this._hidden.destroy(name);
		this.factories.destroy(name);
	}

	Function getFactory(String name) => this.factories.get(name);

	bool hasFactory(String name) => this.factories.has(name);

	void fireFactory(String name,[dynamic n]) => this.hasFactory(name) && this.getFactory(name)(n);
        
	void destroy(){
		this._hidden.clear();
		this.factories.clear();
		this._hidden = this.factories = null;
	}
}

class FunctionalAtomic{
    dynamic _handler;
    FunctionFactory atomics;
    MapDecorator atomicdist;
    MapDecorator _values;
    List _changed;
    
    static create(n) => new FunctionalAtomic(n);

    FunctionalAtomic(this._handler){
      this.atomics = FunctionFactory.create();
      this._values = MapDecorator.create();
      this.atomicdist = MapDecorator.create();
      this._changed = new List();
      this.checkAtomics();
    }

    void addAtomic(String id,Function n(e)){
      this.atomics.addFactory(id,n);
      this.atomicdist.add(id,Distributor.create(id));
      this.checkAtomics();
    }

    void removeAtomic(String id){
      this.atomics.removeFactory(id);
      this.atomicdist.destroy(id);
    }

    void updateAtomic(String id,Function n){
      this.atomics.updateFactory(id,n);
      this.checkAtomics();
    }
    
    void destroy(){
      this.atomics.destroy();
      this._values.clear();
      this.atomicdist.clear();
      this._changed.clear();
    }
  
    void changeHandler(handle){
      this._handler = handle;
    }

    void checkAtomics(){
      if(Valids.notExist(this._handler)) return null;
      Enums.eachAsync(this.atomics.factories.core,(e,i,o,fn){
        var val = e(this._handler);
        var old = this._values.get(i);
        
        if(Valids.notExist(old)){
            this._values.add(i,val);
            return fn(null);
        }
        
        if(Valids.match(val,old)) return fn(null);

        this._values.update(i,val);
        this._changed.add({'id':i,'new':val,'old':old});
        fn(null);
      },(_,i){
         this._changed.forEach((i){
            this.fireAtomic(i['id'],i);
         });
        this._changed.clear();
      });
    }

    void bind(String name,Function n){
            if(!this.atomicdist.has(name)) return null;
            return this.atomicdist.get(name).on(n);
    }

    void bindWhenDone(String name,Function n){
            if(!this.atomicdist.has(name)) return null;
            return this.atomicdist.get(name).whenDone(n);
    }

    void unbindWhenDone(String name,Function n){
            if(!this.atomicdist.has(name)) return null;
            return this.atomicdist.get(name).offWhenDone(n);
    }

    void bindOnce(String name,Function n){
            if(!this.atomicdist.has(name)) return null;
            return this.atomicdist.get(name).once(n);
    }

    void unbind(String name,Function n){
            if(!this.atomicdist.has(name)) return null;
            return this.atomicdist.get(name).off(n);
    }

    void unbindOnce(String name,Function n){
            if(!this.atomicdist.has(name)) return null;
            return this.atomicdist.get(name).offOnce(n);
    }

    void fireAtomic(String n,Map m){
        if(!this.atomicdist.has(n)) return null;
        return this.atomicdist.get(n).emit(m);
    }
}
